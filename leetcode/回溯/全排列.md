#### 回溯算法实现数组全排列

```js
function permute(nums) {
    const result = [];
  
    backtrack(nums, []);
    
    function backtrack(nums, path) {
        if (path.length === nums.length) {
            result.push([...path]);
            return;
        }
        
        if (path.includes(num)) continue;
            // 递
            path.push(num);
            console.log("递->", path, num)
            backtrack(nums, path);
            // 归
            path.pop();
            console.log("归->", path)
    }
    
    return result;
}
  
// 示例用法
const nums = [1, 2, 3];
const permutations = permute(nums);
console.log(permutations);
```

第一次看对这个全排列的递归还是会有些懵逼😒，把递推和回归的过程打印出来，结果如下：
其实就是把没放入一个数的所有情况都遍历到，关键是`什么时候开始回归过程？`
`path`的长度和数组的长度一样，则开始回归
```
递-> [ 1 ] 1

递-> [ 1, 2 ] 2

递-> [ 1, 2, 3 ] 3
归-> [ 1, 2 ]
归-> [ 1 ]
递-> [ 1, 3 ] 3

递-> [ 1, 3, 2 ] 2
归-> [ 1, 3 ]
归-> [ 1 ]
归-> []
递-> [ 2 ] 2

递-> [ 2, 1 ] 1

递-> [ 2, 1, 3 ] 3
归-> [ 2, 1 ]
归-> [ 2 ]
递-> [ 2, 3 ] 3

递-> [ 2, 3, 1 ] 1
归-> [ 2, 3 ]
归-> [ 2 ]
归-> []
递-> [ 3 ] 3

递-> [ 3, 1 ] 1

递-> [ 3, 1, 2 ] 2
归-> [ 3, 1 ]
归-> [ 3 ]
递-> [ 3, 2 ] 2

递-> [ 3, 2, 1 ] 1
归-> [ 3, 2 ]
归-> [ 3 ]
归-> []
```